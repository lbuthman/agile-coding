Rules for Functions

- be small
  -- lines should be <= 150 characters, functions should be <= 20 lines but preferrably 4 lines long
  -- blocks within if, else, and while statements should be one line long, usually a function call
  
- do one thing
  -- Functions should do one thing. They should do it well. They should do it only.
  -- the function is doing one thing if you can't extract another function from it without merely restating the
  name of its implementation
  
- one level of abstraction per function
  -- watch for concepts at different levels creeping into a function, from a high level of accessing a resource
  to a low level of manipulation

- reading code from top to bottom
  -- we want to read the program as though it were a set of TO paragraphs, each of which is describing the current
  level of abstraction and referencing subsequent TO paragraphs at the next level down.
  -- I think this will be aptly applied to deeper dives of pseudo code.
  
- switch statements
  -- bury each switch statement in a low level class so that it is never repeated
  -- to do this, use an Abstract Factory Pattern that hides the switch behind inheritance

- use descriptive names
  -- "You know you are working on clean code when each routine turns out to be pretty much what you expected."
  -- a long descriptive name is better than a short enigmatic one
  
- function arguments
  -- zero is best, then one, followed closely by two, more than that needs to be justified but maybe not used
  at all
  -- arguments require interpretation by the reader
  -- more challenging for testing, each additional argument can create many variations to test
  
- common monadic forms
  1) ask a question about the argument
  2) transforming it is returning the transformed object
  3) an event, that alters the system state but doesn't return anything
  -- try to avoid monadic functions that don't follow these forms. Using an output argument instead of a return
  value for a transformation is confusing
  
- flag argument
  -- passing a boolean into a function is a bad practice because this funciton can now do one of two things, one
  if true and one if false
  -- split the function, one for each case
  
- dyadic functions
  -- the parts of code we ignore are the parts where bugs hide

-triad functions
  -- reducing the number of arguments by creating objects out of them may seem like cheating, but it's not. When
  groups of variables are passed together, it's likely they are part of a concept that deserves a name of its own.

- verbs and keywords
  -- assertEquals would be better as assertExpectedEqualsActual(expected, actual)
  
- output arguments
  -- any name that forces you to check the function signature is equivalent to a double-take. It's a cognitive
  break and should be avoided.
  -- the input parameter shouldn't become the output. The "this" keyword is intended to act as an output argument
  (in the book's example becoming a function of the object)
  -- if your function must change the state of something, have it change the state of its own object

- command query separation
  -- functions should either do something or answer something, but not both
  
- prefer exceptions to returning error codes

- extract try/catch blocks
  -- it is better to extract the bodies of try/catch blocks out into functions of their own
  
- error handling is one thing
  -- a function that handles errors should do nothing else. This implies that if the keyword try exists in a function,
  it should be the first word and there should be nothing after the catch/finally blocks
  
- the single-entry, single-exit rule makes sense when using large functions, but if small functions are preferred,
continue, break, and multiple returns can be expressive, understandable, simple and therefore permissible

- importance of the rewrite
  -- just like crafting a paper, the first version is about getting ideas on paper. Coupled with unit tests, the
  editing/rewrite process can follow the first draft, ensuring the code still works while making it clean

- the art of programming is, and has always been the art of language design. Functions are verbs, classes are nouns.
And Master programmers think of systems as stories to be told rather than programs to be written.
